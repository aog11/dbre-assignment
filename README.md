# DBRE Home Assignment

## The Task

Using Terraform and other configuration tools of your choosing, create an automated way to provisioning and configure the following in Google Cloud Platform:

![enter image description here](https://lh5.googleusercontent.com/TryjxM8ZHsqWc69DkyMVoPmSIe8-ss-7yFzzs3nvTgKtE2Ky7Z7bRTwRsaDCqFD2-sGsJVlhNBhWMGvMlo2r4J-hz2BXU4c6G6YKvlzJaVMvKH1lLLFRMDPME0ik23yyzNHIa2G2)

## Components

### Primary Database

PostgreSQL instance running on 12(or newer), that will serve as primary(master) server. Initialize it with pgbench schema.

### Standby Database

PostgreSQL instance that replicates primary database. Has a daily cron that generates a backup and uploads it to Cloud Storage.

### Cloud Storage

Cloud Storage bucket that will contain daily backups. Has a retention period of 15 days(after that backups are automatically deleted).

### Monitoring

Implement the following alerts on Google Cloud Monitoring.

-   When CPU Usage > 90% on Primary Database.
-   When Disk Usage > 85% on Primary Database.

# Process

### Clone the repo

    git clone https://github.com/aog11/dbre-assignment.git

### Service account configuration
**This  guide assumes the user already has Terraform and Ansible installed on their machine**

First, we need a service account and its key, which we will use to provision the services with Terraform and later on upload the backup file generated by the cronjob to the storage bucket.

1. Login to https://console.cloud.google.com/ using your GCP account
2. Go to IAM & Admin > Service Accounts
3. Click "CREATE SERVICE ACCOUNT"
4. Enter the service account name and click continue
5. Grant the editor role
6. Click Done
7. Once the account is created click on it and go to Keys
8. Next, generate a new key with ADD KEY > Create new key
9.  Key type JSON and click create

After the previous steps are done, a JSON file will be downloaded, place this file under the **files** folder; in order to apply the steps on this assignment, it will be renamed **account.json**. 

### Provisioning the infrastructure with Terraform
Go to the Terraform folder and execute the following to take a look at the resources to be created:

    cd Terraform/
    terraform init
    terraform plan
Run the `terraform apply` to create the resources

Once the resources are created, the output will contain the values that will be used a execution variables necessary for the Ansbiel playbooks, the output will look something like this:

> bucket_url = "gs://postgres_backup_bucket11251"
machine_name = [
  "pgsql-vm1",
  "pgsql-vm2",
]
machine_private_ip = [
  "10.1.0.2",
  "10.1.0.3",
]
machine_public_ip = [
  "34.148.111.52",
  "34.138.155.92",
]

where:
**bucket_url:** The url used by the cronjob in the replica VM to upload the daily backup, used in **Ansible/variables.yml**
**machine_name:** The names of the machines that will be used as master and replica, used in **Ansible/variables.yml**
**machine_private_ip:** The private IP of the VMs, used in the pg_hba.conf file to allow the postgres connections between the machines, used in **Ansible/variables.yml**
**machine_public_ip:** The public IP of the machines, used to connect remote to them via Ansible or a simple SSH connection, used in **files/db_servers**

*Once the machines are created, connect to them with SSH in orde to accept the prompt message asking if you trust these machines, it's better to do it before, since Ansible times out waiting for the user response; in that same vein, in case the VMs are recreated, delete the entries created by them in ~/.ssh/known_hosts to avoid a mismatch in the identification of the previous VM and the new one.*

    ssh dbadmin@machine_public_ip[0]
    ssh dbadmin@machine_public_ip[1]

### Configuring the VMs with Ansible
Once the machines are up and running,  we'll use Ansible to configure the data directory that will be used by postgres, configure the master and replica node, and set up the replication.

**Mounting the postgres data directory and installing PostgreSQL 13**

    cd Ansible/
    ansible-playbook -i ../files/db_servers vm_config.yml

This first playbook with format the additional disk attached to the VMs and configure and initialize our postgres installation, executes on both machines.

**Configuring the master node**

    ansible-playbook -i ../files/db_servers master_node_config.yml
Starts the postgresql-13 service in the master node, creates the replication slots to be used by the replication process and initializes the pgbench schema in a database created with the same name; executes in the VM set as the master.

**Configuring the replica node**

    ansible-playbook -i ../files/db_servers  replica_node_config.yml
Sets up the replication parameters in postgresql.conf in the replica node, copies the data directory from the master node and configures the cronjob for the daily backup; executes in the VM set as the replica.


### Validating the replication
The replication can be validated by making a connection to either node and executing some commands in the shell and the database to check that it's set up correctly; these commands have been collected in the replication_validation.yml playbook which runs in both nodes to check the replication status:

    ansible-playbook -i ../files/db_servers replication_validation.yml
the output of this playbook should indicate the status of the postgresql service on each node showing if replication is active, the expected output being:
 - f on master / t on replica
 - walsender PID on master / walreceiver PID on replica

### Uploading backup files to Storage Bucket
Lastly, to check if the connection with the service account  to the storage bucket is valid, execute the database backup script in the replica node to upload a file

    ssh dbadmin@machine_public_ip[1]
    [dbadmin@pgsql-vm2 ~]$ sudo su - postgres
    [postgres@pgsql-vm2 ~]$ /var/lib/pgsql/db_backup.sh
    Copying file:///var/lib/pgsql/13/backups/db_backup_20220302.sql [ContentType=application/octet-stream]...
    / [1 files][  9.0 MiB/  9.0 MiB]                                                
    Operation completed over 1 objects/9.0 MiB.                                      
    [postgres@pgsql-vm2 ~]$ 
